# =====================================================
# PostgreSQL Configuration for IPO Valuation Platform
# Optimized for financial data workloads
# =====================================================

# =====================================================
# CONNECTION AND AUTHENTICATION
# =====================================================

# Connection settings
listen_addresses = '*'                    # Listen on all interfaces
port = 5432                              # Standard PostgreSQL port
max_connections = 200                    # Sufficient for web application load
superuser_reserved_connections = 3       # Reserve connections for superuser

# SSL settings for secure connections
ssl = on
ssl_cert_file = '/etc/ssl/certs/server.crt'
ssl_key_file = '/etc/ssl/private/server.key'
ssl_ca_file = '/etc/ssl/certs/ca.crt'
ssl_ciphers = 'HIGH:MEDIUM:+3DES:!aNULL'

# Authentication
password_encryption = scram-sha-256      # Modern password encryption

# =====================================================
# MEMORY CONFIGURATION
# =====================================================

# Buffer pool - 25% of total RAM for dedicated database server
shared_buffers = 2GB                     # Adjust based on available RAM
effective_cache_size = 6GB               # Total memory available for caching

# Work memory for sorts and hash joins
work_mem = 16MB                          # Per operation memory
maintenance_work_mem = 512MB             # Memory for maintenance operations
max_stack_depth = 7MB                    # Stack depth limit

# Temporary files
temp_file_limit = 2GB                    # Limit for temporary file space

# =====================================================
# WRITE-AHEAD LOGGING (WAL)
# =====================================================

# WAL configuration for performance and durability
wal_level = replica                      # Enable replication
wal_sync_method = fsync                  # Synchronization method
synchronous_commit = on                  # Ensure transaction durability
wal_compression = on                     # Compress WAL records

# WAL buffer and checkpointing
wal_buffers = 64MB                       # WAL buffer size
checkpoint_timeout = 15min               # Maximum time between checkpoints
checkpoint_completion_target = 0.9       # Spread checkpoint I/O
max_wal_size = 4GB                       # Maximum WAL size before checkpoint
min_wal_size = 1GB                       # Minimum WAL size

# Archive settings for backup
archive_mode = on
archive_command = 'test ! -f /var/lib/postgresql/archive/%f && cp %p /var/lib/postgresql/archive/%f'
archive_timeout = 300                    # Force archive every 5 minutes

# =====================================================
# QUERY PLANNER
# =====================================================

# Cost-based optimizer settings
seq_page_cost = 1.0                      # Sequential page access cost
random_page_cost = 2.0                   # Random page access cost (SSD optimized)
cpu_tuple_cost = 0.01                    # CPU cost per tuple
cpu_index_tuple_cost = 0.005             # CPU cost per index tuple
cpu_operator_cost = 0.0025               # CPU cost per operator

# Join settings
enable_hashjoin = on
enable_mergejoin = on
enable_nestloop = on
enable_material = on
enable_sort = on

# Parallelism settings
max_parallel_workers_per_gather = 4      # Parallel workers per query
max_parallel_workers = 8                 # Total parallel workers
max_worker_processes = 16                # Maximum background processes
parallel_tuple_cost = 0.1                # Cost of transferring tuple between workers
parallel_setup_cost = 1000.0             # Cost of setting up parallel execution

# =====================================================
# BACKGROUND WRITER AND AUTOVACUUM
# =====================================================

# Background writer settings
bgwriter_delay = 200ms                   # Background writer sleep delay
bgwriter_lru_maxpages = 100              # Maximum pages to write per round
bgwriter_lru_multiplier = 2.0            # Multiplier for next round estimation

# Autovacuum settings - critical for maintaining performance
autovacuum = on                          # Enable autovacuum
autovacuum_max_workers = 6               # Maximum autovacuum workers
autovacuum_naptime = 30s                 # Time between autovacuum runs

# Aggressive autovacuum for high-write tables
autovacuum_vacuum_threshold = 50         # Minimum number of updated/deleted tuples
autovacuum_vacuum_scale_factor = 0.1     # Fraction of table size to add to threshold
autovacuum_analyze_threshold = 50        # Minimum number of inserted/updated/deleted tuples
autovacuum_analyze_scale_factor = 0.05   # Fraction of table size for analyze

# Vacuum cost delay to prevent I/O overwhelming
autovacuum_vacuum_cost_delay = 10ms      # Cost delay for autovacuum
autovacuum_vacuum_cost_limit = 1000      # Cost limit for autovacuum

# =====================================================
# LOGGING AND MONITORING
# =====================================================

# Logging configuration
logging_collector = on                   # Enable log collection
log_destination = 'csvlog'               # CSV format for better parsing
log_directory = '/var/log/postgresql'    # Log directory
log_filename = 'postgresql-%Y-%m-%d.log' # Daily log rotation
log_file_mode = 0600                     # Log file permissions
log_rotation_age = 1d                    # Rotate logs daily
log_rotation_size = 100MB                # Rotate logs when they reach 100MB
log_truncate_on_rotation = on            # Truncate old logs

# What to log
log_connections = on                     # Log connections
log_disconnections = on                  # Log disconnections
log_duration = off                       # Don't log all statement durations
log_statement = 'ddl'                    # Log DDL statements
log_min_duration_statement = 1000       # Log slow queries (>1 second)
log_checkpoints = on                     # Log checkpoint activity
log_lock_waits = on                      # Log lock waits
log_temp_files = 10MB                    # Log temp files larger than 10MB

# Log level and details
log_min_messages = notice                # Minimum message level
log_min_error_statement = error          # Log statements that cause errors
log_line_prefix = '%t [%p]: [%l-1] user=%u,db=%d,app=%a,client=%h '

# =====================================================
# STATISTICS AND MONITORING
# =====================================================

# Query statistics
track_activities = on                    # Track running queries
track_counts = on                        # Track table and index usage
track_io_timing = on                     # Track I/O timing
track_functions = all                    # Track function call statistics

# Statement statistics (requires pg_stat_statements extension)
shared_preload_libraries = 'pg_stat_statements'
pg_stat_statements.max = 10000           # Maximum number of statements tracked
pg_stat_statements.track = all           # Track all statements
pg_stat_statements.track_utility = off   # Don't track utility statements
pg_stat_statements.save = on             # Save statistics across restarts

# =====================================================
# REPLICATION AND STANDBY
# =====================================================

# Hot standby settings
hot_standby = on                         # Allow queries during recovery
max_standby_archive_delay = 30s          # Maximum delay for archive recovery
max_standby_streaming_delay = 30s        # Maximum delay for streaming recovery
wal_receiver_status_interval = 10s       # Status update interval for receiver
hot_standby_feedback = on                # Send feedback to master

# Replication settings
max_wal_senders = 5                      # Maximum WAL sender processes
max_replication_slots = 5                # Maximum replication slots
wal_keep_segments = 64                   # Keep WAL segments for replication
wal_sender_timeout = 60s                 # Sender timeout

# =====================================================
# SECURITY SETTINGS
# =====================================================

# Security settings
ssl_prefer_server_ciphers = on           # Prefer server cipher order
row_security = on                        # Enable row-level security

# Prevent privilege escalation
allow_system_table_mods = off
ignore_system_indexes = off

# =====================================================
# FINANCIAL DATA SPECIFIC OPTIMIZATIONS
# =====================================================

# Increase limits for complex financial calculations
max_locks_per_transaction = 256          # Increase for complex queries
max_pred_locks_per_transaction = 128     # For serializable transactions
max_pred_locks_per_relation = 64         # Per relation predicate locks

# Custom settings for financial data precision
bytea_output = hex                       # Output format for binary data
datestyle = 'ISO, YMD'                   # Standard date format
timezone = 'UTC'                         # Use UTC for all timestamps
lc_monetary = 'C'                        # Use C locale for money formatting

# =====================================================
# EXTENSIONS CONFIGURATION
# =====================================================

# Load required extensions at startup
shared_preload_libraries = 'pg_stat_statements,pg_buffercache,pg_prewarm,auto_explain'

# Auto explain settings for performance debugging
auto_explain.log_min_duration = 5s       # Log plans for queries >5 seconds
auto_explain.log_analyze = on            # Include actual run times
auto_explain.log_buffers = on            # Include buffer usage
auto_explain.log_verbose = off           # Don't include verbose output
auto_explain.log_nested_statements = on  # Log nested statements

# =====================================================
# PARTITIONING OPTIMIZATION
# =====================================================

# Enable constraint exclusion for partitioning
constraint_exclusion = partition         # Enable for partitioned tables
enable_partition_pruning = on            # Enable partition pruning
enable_partitionwise_join = on           # Enable partition-wise joins
enable_partitionwise_aggregate = on      # Enable partition-wise aggregates

# =====================================================
# JSON AND JSONB OPTIMIZATION
# =====================================================

# No specific settings, but consider these best practices:
# - Use JSONB instead of JSON for better performance
# - Create GIN indexes on JSONB columns for fast searches
# - Use jsonb_path_ops operator class for simple containment queries

# =====================================================
# BACKUP AND RECOVERY SETTINGS
# =====================================================

# Settings for backup performance
archive_timeout = 300                    # Force WAL archival every 5 minutes
wal_compression = on                     # Compress WAL files

# Recovery settings
recovery_target_timeline = 'latest'     # Recover to latest timeline
restore_command = 'cp /var/lib/postgresql/archive/%f %p'

# =====================================================
# CONNECTION POOLING CONSIDERATIONS
# =====================================================

# These settings work well with connection poolers like PgBouncer
# Adjust max_connections based on pooler configuration
# Use session pooling for compatibility with all features
# Consider statement or transaction pooling for better performance

# =====================================================
# PERFORMANCE MONITORING QUERIES
# =====================================================

# Enable these views for monitoring:
# - pg_stat_activity: Current activity
# - pg_stat_database: Database statistics  
# - pg_stat_user_tables: Table statistics
# - pg_stat_user_indexes: Index usage statistics
# - pg_stat_statements: Query performance statistics
# - pg_stat_bgwriter: Background writer statistics

# =====================================================
# MAINTENANCE COMMANDS
# =====================================================

# Regular maintenance commands to run:
# - VACUUM ANALYZE for table maintenance
# - REINDEX for index maintenance  
# - UPDATE STATISTICS for query planner
# - pg_stat_reset() to reset statistics

# =====================================================
# TUNING BASED ON WORKLOAD
# =====================================================

# For read-heavy workloads (analytics):
# - Increase effective_cache_size
# - Increase work_mem for complex queries
# - Enable parallel query processing
# - Consider materialized views for common aggregations

# For write-heavy workloads (real-time data):
# - Increase checkpoint_segments
# - Reduce checkpoint_completion_target
# - Increase wal_buffers
# - Tune autovacuum more aggressively

# For mixed workloads:
# - Balance the above settings
# - Use connection pooling
# - Monitor and adjust based on actual usage patterns

# =====================================================
# CLOUD SPECIFIC SETTINGS (GCP Cloud SQL)
# =====================================================

# When using GCP Cloud SQL, some settings are managed:
# - Automated backups and point-in-time recovery
# - High availability with automatic failover
# - Read replicas for scaling read workloads
# - Automatic storage scaling
# - Maintenance windows for updates

# Cloud SQL specific flags to consider:
# - cloudsql.iam_authentication = on (for IAM-based auth)
# - cloudsql.enable_pg_audit = on (for audit logging)
# - max_connections (based on machine type)
# - shared_buffers (automatically set based on memory)